---
description: Использование скалярного произведения
---

# Кейс 2: оценка релевантности объекта

Скалярное произведение векторов используется в задачах, где важно не расстояние между объектами и не только направление в пространстве признаков, а **вклад каждого признака в итоговый результат**. Такой подход лежит в основе линейных моделей, скоринга и большинства систем ранжирования.

### Постановка задачи

Рассмотрим задачу оценки релевантности объекта. Пусть у нас есть набор объектов (например, пользователей, товаров или документов), и каждый из них описывается числовыми признаками:

* частота использования
* уровень активности
* недавность взаимодействия

Каждый признак вносит разный вклад в итоговую оценку. Это знание мы кодируем в виде вектора весов.

Объект представляется вектором признаков

$$
[
\mathbf{x} = (x_1, x_2, \dots, x_n)
]
$$

А модель — вектором весов

$$
[
\mathbf{w} = (w_1, w_2, \dots, w_n)
]
$$

#### Почему именно скалярное произведение

Скалярное произведение вычисляет взвешенную сумму признаков:

$$
[
\mathbf{x} \cdot \mathbf{w} = \sum_i x_i w_i
]
$$

В этом кейсе:

* важна **сила признаков**, а не только их относительные пропорции
* масштаб значений имеет смысл
* вклад каждого признака явно контролируется весами

Поэтому ни евклидово расстояние, ни косинусное сходство здесь не подходят.

### Вариант 1. Реализация на чистом PHP

#### Скалярное произведение

```php
function dotProduct(array $a, array $b): float {
    $n = count($a);

    if ($n !== count($b)) {
        throw new InvalidArgumentException('Vectors must have the same length');
    }

    $sum = 0.0;

    for ($i = 0; $i < $n; $i++) {
        $sum += $a[$i] * $b[$i];
    }

    return $sum;
}
```

#### Пример скоринга объекта

```php
$features = [10, 5, 2];   // активность, сессии, покупки
$weights  = [0.3, 0.5, 1.2];

$score = dotProduct($features, $weights);

// 10*0.3 + 5*0.5 + 2*1.2 = 7.9
echo $score;
```

Чем выше значение, тем выше оценка релевантности объекта.

#### Интерпретация результата

* первый признак вносит вклад 3.0
* второй – 2.5
* третий – 2.4

Результат легко интерпретируется и объясняется, что особенно важно в прикладных задачах.

### Вариант 2. Реализация с использованием Rubix ML

В Rubix ML скалярное произведение используется внутри линейных моделей. Рассмотрим пример линейной регрессии без обучения – с заранее заданными весами.

#### Пример линейного скоринга

```php
use Rubix\ML\Datasets\Unlabeled;
use Rubix\ML\Regressors\LinearRegression;

$samples = [
    [10, 5, 2],   // объект A
    [4,  1, 0],   // объект B
    [20, 8, 5],   // объект C
];

// Фиктивные целевые значения (для примера)
$labels = [8, 2, 15];

$dataset = new \Rubix\ML\Datasets\Labeled($samples, $labels);

$model = new LinearRegression();
$model->train($dataset);

// Новый объект
$newSample = [[12, 6, 3]];

$prediction = $model->predict(new Unlabeled($newSample));
print_r($prediction);
```

#### Что происходит внутри

После обучения Rubix ML:

* подбирает веса ($$\mathbf{w}$$)
* для каждого нового объекта считает\
  $$[ \mathbf{x} \cdot \mathbf{w} + b ]$$
* именно скалярное произведение формирует основу предсказания

### Связь с линейными моделями

Скалярное произведение — это сердце линейных моделей:

* линейная регрессия
* логистическая регрессия
* линейные классификаторы
* нейронные сети (на уровне отдельных нейронов)

Каждый нейрон фактически вычисляет скалярное произведение входов и весов.

### Короткий вывод

{% hint style="info" %}
Скалярное произведение используется в задачах, где важно учитывать вклад каждого признака в результат. Оно позволяет напрямую моделировать влияние признаков и лежит в основе линейных моделей и скоринговых систем.
{% endhint %}

Эта идея станет ключевой при переходе к обучаемым моделям, где веса вектора ($$\mathbf{w}$$) подбираются автоматически на данных.
