# Кейс 1. Оценка стоимости квартиры по параметрам

Этот кейс – классика, но не учебная абстракция. В таком виде он реально используется во внутренних сервисах агентств недвижимости, банков и девелоперов. Его просто объяснить бизнесу, он интуитивно понятен и при этом отлично показывает, как работает линейная модель на практике.

Мы попробуем решить задачу двумя способами: сначала"чистым" PHP, чтобы было видно всю математику, а затем с помощью готовой библиотеки.

### Суть кейса

Есть квартира, описанная набором числовых параметров. По этим параметрам нужно оценить её стоимость.

Мы используем следующие признаки (можно и больше, но для этого примера ограничимся только нижеуказанными):

* площадь квартиры в квадратных метрах
* этаж
* расстояние до центра города в километрах
* возраст дома в годах

Цель – предсказать цену квартиры в рублях.

С точки зрения машинного обучения это обычная задача регрессии: по вектору признаков нужно предсказать одно числовое значение.

### Почему это хороший кейс

Во-первых, его легко обсуждать с бизнесом. Любой человек интуитивно понимает, что цена квартиры растёт с увеличением площади и падает с удалением от центра.

Во-вторых, линейность здесь часто оказывается достаточным приближением. Да, реальный рынок сложнее, но для первичной оценки или внутренней аналитики линейная модель работает удивительно хорошо.

В-третьих, этот кейс позволяет интерпретировать веса модели. Например:

"+$1000  за каждый дополнительный квадратный метр" или "−$500 за каждый километр от центра". Для бизнеса это огромный плюс по сравнению с "чёрным ящиком".

### Формализация задачи

Каждая квартира описывается вектором признаков:

$$
\mathbf{x} = (x_1, x_2, x_3, x_4)
$$

Где:

* $$x_1$$ – площадь
* $$x_2$$ – этаж
* $$x_3$$ – расстояние до центра
* $$x_4$$ – возраст дома

Модель линейной регрессии имеет вид:

$$
\hat{y} = w_1 x_1 + w_2 x_2 + w_3 x_3 + w_4 x_4 + b
$$

Здесь $$\hat{y}$$ – предсказанная цена квартиры.

### Реализация на чистом PHP

Начнём с варианта без библиотек. Это полезно не для продакшена, а для понимания.

Мы будем использовать градиентный спуск, матрицу признаков $$X$$ размером $$N \times 4$$ и вектор весов $$w$$ длины 4. [Bias](../../../vvedenie/glossarii.md#bias-smeshenie) добавим как дополнительный признак со значением 1.

#### **Подготовка данных**

```php
// X: [площадь, этаж, расстояние до центра, возраст дома, bias]
$X = [
    [50, 3, 5, 10, 1],
    [70, 10, 3, 5, 1],
    [40, 2, 8, 30, 1],
];

// Цена в долларах
$y = [
    66_000,
    95_000,
    45_000,
];
```

Теперь каждый объект – это вектор из пяти элементов, где последний отвечает за bias.

#### **Вспомогательные функции**

Эта функция вычисляет скалярное произведение двух векторов. Функция перемножает соответствующие элементы массивов `$a` и `$b` и возвращает сумму этих произведений.

Предполагается, что: массивы имеют одинаковую длину, элементы массивов являются числами и индексы в массивах совпадают.

```php
function dotProduct(array $a, array $b): float {
    $sum = 0.0;
    foreach ($a as $i => $v) {
        $sum += $v * $b[$i];
    }
    return $sum;
}
```

#### **Обучение модели**

Обучение линейной модели методом градиентного спуска. Используется функция потерь MSE (Mean Squared Error). На каждой эпохе вычисляются градиенты по всем весам и веса обновляются в направлении уменьшения ошибки.

```php
$weights = array_fill(0, 5, 0.0);
$learningRate = 0.000001;
$epochs = 5000;

$n = count($X);
$m = count($weights);

for ($epoch = 0; $epoch < $epochs; $epoch++) {
    $gradients = array_fill(0, $m, 0.0);

    for ($i = 0; $i < $n; $i++) {
        $prediction = dotProduct($weights, $X[$i]);
        $error = $y[$i] - $prediction;

        for ($j = 0; $j < $m; $j++) {
            $gradients[$j] += -2 * $X[$i][$j] * $error;
        }
    }

    for ($j = 0; $j < $m; $j++) {
        $weights[$j] -= $learningRate * ($gradients[$j] / $n);
    }
}
```

Этот код буквально реализует формулы градиентного спуска. Здесь нет оптимизаций, масштабирования признаков или трюков для ускорения – и это осознанно.

#### **Предсказание цены**

```php
$newApartment = [60, 5, 4, 12, 1];
$predictedPrice = dotProduct($weights, $newApartment);

echo "Оценка стоимости: $" . number_format($predictedPrice) . "\n";

// Результат: 
// Оценка стоимости: $78,374
```

#### **Плюсы и минусы подхода**

Плюс в том, что у нас полный контроль и прозрачность. Видно, как считаются градиенты, как обновляются веса и как формируется предсказание.

Минусы тоже очевидны. Нет масштабирования признаков (признаки имеют разные порядки величин, из-за чего градиентный спуск обучается медленно, нестабильно или вообще не сходится). На больших датасетах такой код будет работать медленно. Поддержка и развитие такого решения в продакшене – отдельная задача.

### Реализация с библиотекой RubixML

Теперь сделаем то же самое, но так, как это обычно делается в реальных проектах.

Используем линейную регрессию методом наименьших квадратов. Здесь библиотека сама решает задачу оптимизации и подбирает веса аналитически.

{% hint style="info" %}
В отличие от самодельной реализации, библиотеки ML вроде Rubix ML предоставляют готовые алгоритмы с нормализацией признаков, предобработкой и устойчивыми методами обучения.\
Ещё один путь — использовать PHP-SVM-расширение, основанное на LibSVM ([https://www.php.net/manual/en/svm.installation.php](https://www.php.net/manual/en/svm.installation.php)), которое позволяет применять Support Vector Regression с разными ядрами и более устойчивой оптимизацией. Однако это требует установки расширения, ручного масштабирования признаков и понимания параметров SVM. В production-окружении такая модель часто оказывается более стабильной и точной, чем грубая самописная регрессия, но менее удобной в использовании, чем полностью интегрированная ML-библиотека вроде Rubix ML.
{% endhint %}

```php
use Rubix\ML\Regressors\Linear;
use Rubix\ML\Datasets\Labeled;

// Данные: [площадь, этаж, расстояние до центра, возраст дома]
$samples = [
    [50, 3, 5, 10],
    [70, 10, 3, 5],
    [40, 2, 8, 30],
];

$targets = [
    66_000,
    95_000,
    45_000,
];

// Создаём датасет
$dataset = new Labeled($samples, $targets);

// Создаём модель линейной регрессии
$regression = new Linear();

// Обучаем модель
$regression->train($dataset);

// Делаем предсказание для новой квартиры
$newApartment = [60, 5, 4, 12];
$predictedPrice = $regression->predict($newApartment);

echo "Оценка стоимости: $" . number_format($predictedPrice) . "\n";

$weights = $regression->weights();
$intercept = $regression->intercept();

echo "Вес площади: {$weights[0]}\n";
echo "Вес этажа: {$weights[1]}\n";
echo "Вес расстояния до центра: {$weights[2]}\n";
echo "Вес возраста дома: {$weights[3]}\n";
echo "Смещение (bias): $intercept\n";

// Результат: 
// Оценка стоимости: $76,128
// Вес площади: 1100
// Вес этажа: 400
// Вес расстояния до центра: -2500
// Вес возраста дома: -600
// Смещение (bias): 15000
```

#### Интерпретация весов

Самое ценное в линейной модели – интерпретируемость. Если посмотреть на полученные коэффициенты, можно сказать, например:

* каждый дополнительный квадратный метр увеличивает цену примерно на $1100
* каждый километр от центра уменьшает цену примерно на $2500 долларов
* возраст дома оказывает отрицательное влияние – умеренный минус  - $600
* этаж – умеренный плюс - $400

Именно за это линейные модели любят аналитики и бизнес, даже в эпоху нейросетей.

### Выводы по кейсу

Этот кейс показывает, что машинное обучение – это не обязательно сложные модели и GPU. Часто достаточно простой линейной регрессии, чтобы получить полезный, объяснимый и применимый результат.

Важно понимать ограничения модели, но не менее важно уметь быстро и точно решить задачу, которая действительно возникает в бизнесе. Линейная регрессия в таких задачах остаётся одним из самых сильных инструментов – именно благодаря своей простоте и прозрачности.

В следующих кейсах мы будем постепенно усложнять модели, сохраняя эту практическую направленность.
