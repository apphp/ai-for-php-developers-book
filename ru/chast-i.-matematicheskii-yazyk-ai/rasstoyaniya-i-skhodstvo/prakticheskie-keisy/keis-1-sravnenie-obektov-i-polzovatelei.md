---
description: Использование евклидова расстояния
---

# Кейс 1: Сравнение объектов и пользователей

Когда требуется сравнивать числовые объекты, евклидово расстояние часто оказывается самым естественным выбором. Оно хорошо работает в ситуациях, где признаки имеют сопоставимый смысл и находятся в одном масштабе. В таких условиях расстояние напрямую отражает степень близости объектов.

Скалярное произведение, в свою очередь, чаще применяется в рекомендательных системах. Оно позволяет оценить, насколько пользователь и объект "подходят" друг другу: чем больше значение, тем сильнее совпадение, причём учитывается не только направление предпочтений, но и их выраженность.

<div align="left"><figure><img src="../../../.gitbook/assets/7.6-users-and-products-in-one-space.png" alt="" width="563"><figcaption><p>Пользователи и товары в одном пространстве</p></figcaption></figure></div>

### Постановка задачи

Рассмотрим типичную задачу из прикладного машинного обучения и рекомендательных систем. У нас есть пользователи и объекты (товары, сервисы, подписки), описанные набором числовых признаков. Мы хотим понять, какие пользователи похожи друг на друга и какие объекты им подходят.

Предположим, каждый пользователь описывается вектором:

$$
x = (\text{возраст}, \text{доход}, \text{частота покупок})
$$

Это классический случай, где признаки:

* имеют понятный физический смысл
* измеряются в разных единицах
* должны вносить сопоставимый вклад

#### Шаг 1: нормализация признаков

Без нормализации евклидово расстояние работать корректно не будет. Доход в тысячах единиц просто "раздавит" возраст и частоту покупок.

Один из простейших и часто используемых подходов – это min-max нормализация:

$$
x_i’ = \frac{x_i - \min(x_i)}{\max(x_i) - \min(x_i)}
$$

В реальном проекте min и max считаются по всей выборке, но для примера зафиксируем их вручную.

```php
function normalize(array $x, array $min, array $max): array {
    $result = [];
    
    foreach ($x as $i => $value) {
        $result[$i] = ($value - $min[$i]) / ($max[$i] - $min[$i]);
    }
    
    return $result;
}
```

Допустим, у нас есть два пользователя:

```php
// = [возраст, доход, покупок в месяц]
$userA = [25, 3000, 5];  
$userB = [40, 5000, 8];

$min = [18, 1000, 1];
$max = [65, 10000, 20];

$userANorm = normalize($userA, $min, $max);
$userBNorm = normalize($userB, $min, $max);

// Результат:
// $userANorm = [0.1489, 0.2222, 0.2105]
// $userBNorm = [0.4681, 0.4444, 0.3684]
```

После нормализации оба пользователя превращаются в точки в одном и том же масштабе.

#### Шаг 2: евклидово расстояние между пользователями

Теперь мы можем корректно измерить "общую близость" профилей.

Формула евклидова расстояния:

$$
d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}
$$

PHP-реализация:

```php
function euclideanDistance(array $a, array $b): float {
    $n = count($a);

    if ($n !== count($b)) {
        throw new InvalidArgumentException('Vectors must have the same length');
    }

    $sum = 0.0;

    for ($i = 0; $i < $n; $i++) {
        $diff = $a[$i] - $b[$i];
        $sum += $diff ** 2;
    }

    return sqrt($sum);
}
```

Использование:

```php
$distance = euclideanDistance($userANorm, $userBNorm);

// Результат: 0.4197
// Объяснение: d = (0.1489 − 0.4681)^2 + (0.2222 − 0.4444)^2 + (0.2105 − 0.3684)^2 ≈ 0.4197
```

Малое значение означает, что пользователи похожи по совокупности признаков. В нашем случае расстояние ≈ 0.4197 означает, что пользователи довольно хорошо различаются по возрасту, доходу и активности покупок.&#x20;

{% hint style="warning" %}
Под "малым" евклидовым расстоянием понимается значение, близкое к нулю и существенно меньше типичных расстояний между объектами в выборке (как правило, менее 0.2–0.3 для нормализованных признаков).
{% endhint %}

Именно по этому принципу работают:

* [k-NN](../../../vvedenie/glossarii.md#k-nn-k-nearest-neighbors-k-blizhaishikh-sosedei) для поиска похожих пользователей
* сегментация клиентов
* [cold-start рекомендации](../../../vvedenie/glossarii.md#cold-start-problema-kholodnogo-starta-v-rekomendaciyakh)

Важно подчеркнуть: евклидово расстояние отвечает на вопрос "насколько профили близки в целом", а не "насколько они хорошо взаимодействуют с каким-нибудь объектом".

#### Шаг 3: переход к объектам и dot product

Теперь добавим объекты – например, товары. Пусть каждый товар описывается вектором предпочтений:

$$
y = (\text{ориентация на возраст}, \text{ориентация на доход}, \text{ориентация на активность})
$$

Это уже не профиль пользователя, а направление, в котором "смотрит" товар.

Пример:

```php
$item = [0.2, 0.9, 0.7];
```

Теперь мы хотим понять, насколько пользователь и товар подходят друг другу. Здесь евклидово расстояние уже не так удобно. Нам важно, чтобы большие значения признаков пользователя усиливали релевантные признаки товара.

Именно здесь появляется dot product:

$$
x \cdot y = \sum_{i=1}^{n} x_i y_i
$$

PHP-код:

```php
function dotProduct(array $a, array $b): float {
    $sum = 0.0;
    
    foreach ($a as $i => $value) {
        $sum += $value * $b[$i];
    }
    
    return $sum;
}
```

Использование:

```php
$score = dotProduct($userANorm, $item);

// Результат: 0.3771
// Объяснение: 
// score = (0.1489 * 0.2) + (0.2222 * 0.9) + (0.2105 * 0.7) 
//       = 0.02978 + 0.19998 + 0.14735 
//       = 0.3771
```

Если значение большое, это означает: пользователь сильно выражен по тем признакам, которые важны для данного товара.

В нашем случае по результату можно сделать вывод: если этот товар важен для людей с высоким доходом и активными покупками, то пользователь A подходит умеренно, но не идеально.

Такая оценка (score) – это основа рекомендательных систем:

* матричная факторизация
* embeddings пользователей и товаров
* нейросетевые рекомендатели

#### Почему здесь работают разные меры

Евклидово расстояние хорошо отвечает на вопрос: "Кто из пользователей похож друг на друга?"

Dot product отвечает на другой вопрос: "Насколько хорошо пользователь и объект сочетаются?"

Это принципиально разные задачи, и попытка решать их одной и той же мерой часто приводит к плохим результатам.

Если сказать коротко, но точно:

* расстояние – про близость
* скалярное произведение – про взаимодействие и силу отклика

#### Практическое резюме кейса

{% hint style="warning" %}
Важно: в реальных системах эти два подхода почти всегда используются вместе. Сначала мы ищем похожих пользователей или сегменты с помощью евклидова расстояния. Затем внутри сегмента ранжируем объекты с помощью dot product.
{% endhint %}

Именно такая комбинация лежит в основе большинства production-рекомендательных систем – от простых e-commerce решений до сложных ML-пайплайнов.
