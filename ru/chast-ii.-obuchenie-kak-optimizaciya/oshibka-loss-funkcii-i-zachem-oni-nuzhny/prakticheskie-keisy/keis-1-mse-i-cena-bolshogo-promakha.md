# Кейс 1: MSE и цена большого промаха

#### Прогноз цены и влияние выбросов (MSE на практике)

Начнём с простого и очень жизненного примера. Представим сервис оценки стоимости квартир. Ничего сложного: на вход подаётся площадь, на выходе – прогнозируемая цена. Это типичная задача регрессии, и для неё почти автоматически выбирают [MSE](../../../vvedenie/glossarii.md#mse-mean-squared-error).

Но именно здесь хорошо видно, какую цену мы платим за такой выбор.

#### **Цель кейса**

Показать, как MSE резко реагирует на выбросы и почему одна плохая точка может испортить модель.

#### **Сценарий**

У нас есть несколько квартир с известной реальной ценой и предсказаниями модели. Для простоты будем считать, что модель уже обучена, а мы лишь оцениваем качество её работы.

> Важно: ниже мы считаем ошибку уже готовой модели, но именно такое поведение MSE при оценке напрямую определяет и то, как модель будет обучаться, поскольку при обучении оптимизируется та же самая функция потерь.

Реальные цены (в условных единицах):

```php
$y = [100, 120, 130, 115, 125];
```

Предсказания модели:

```php
$yHat = [102, 118, 128, 117, 123];
```

Ошибки есть, но они небольшие. Это выглядит как вполне адекватные предсказания на данном наборе данных.

#### **Напоминание: как считается MSE**

Реализуем MSE буквально в несколько строк, без каких-либо библиотек:

```php
function mse(array $y, array $yHat): float {
    $n = count($y);
    $sum = 0.0;

    for ($i = 0; $i < $n; $i++) {
        $diff = $y[$i] - $yHat[$i];
        $sum += $diff * $diff;
    }

    return $sum / max($n, 1);
}
```

Посчитаем ошибку:

```php
echo 'Normal MSE: ' . mse($y, $yHat);

// Результат:
// Normal MSE: 4
```

Значение MSE получается небольшим. Это ожидаемо: все ошибки лежат в пределах нескольких единиц, и возведение в квадрат лишь умеренно усиливает их вклад.

#### **Добавляем одну "плохую" квартиру**

Теперь испортим картину всего одной точкой. Пусть в данных появилась странная квартира: либо ошибка в базе, либо уникальный объект, либо просто неудачный прогноз. Добавим выброс.

Реальная цена:

```php
$y[] = 300;
```

Предсказание модели:

```php
$yHat[] = 130;
```

Ошибка здесь огромная. Посчитаем MSE снова:

```php
echo 'MSE with outlier: ' . mse($y, $yHat)ж

// Результат:
// MSE with outlier: 4820
```

И вот тут происходит ключевой момент кейса.

#### **Что мы видим**

MSE вырос не просто заметно, а непропорционально сильно. Хотя новых данных всего одна точка, именно она начинает доминировать над всей функцией потерь.

Почему так происходит, легко увидеть на уровне одной формулы:

$$
(300 - 130)^2 = 170^2 = 28900
$$

Для сравнения, все предыдущие ошибки давали квадраты порядка единиц (в редких случаях – десятков). Один промах буквально "перекрикивает" все остальные наблюдения.

В режиме обучения этот эффект проявляется ещё сильнее.

<div align="left"><figure><img src="../../../.gitbook/assets/10.1-case-1-mse-and-cost-of-big- miss.png" alt="" width="563"><figcaption><p>10.1 MSE и цена большого промаха</p></figcaption></figure></div>

#### **Почему это не баг**

Очень важно понять: такое поведение MSE – осознанное свойство, а не ошибка дизайна.

Используя квадратичную ошибку, мы заранее говорим модели:

> Большие промахи гораздо хуже, чем много маленьких.

Это разумно во многих задачах. Например:

* в прогнозе цен для банка
* в расчётах рисков
* в инженерных и физических моделях

Там один крупный промах может стоить дороже, чем десяток мелких неточностей.

#### **Но за это есть цена**

Обратная сторона очевидна. Если в данных есть:

* выбросы
* ошибки разметки
* редкие, но экстремальные значения

MSE начинает подстраивать модель именно под них. Иногда в ущерб большинству "нормальных" данных.

Этот кейс важен не потому, что MSE плох. А потому, что он ясно показывает: loss-функция – это выбор приоритетов.

#### **Ключевой вывод**

MSE не просто измеряет ошибку. Он задаёт модельному обучению философию:

* большие ошибки недопустимы
* выбросы имеют решающее значение
* стабильность достигается ценой чувствительности

В следующих кейсах мы увидим, как эти же идеи проявляются при сравнении моделей и почему для классификации такая логика уже не работает.

{% hint style="info" %}
Чтобы самостоятельно протестировать этот код, установите примеры из официального репозитория [GitHub](https://github.com/apphp/ai-for-php-developers-examples) или воспользуйтесь [онлайн-демонстрацией](https://aiwithphp.org/books/ai-for-php-developers/examples/part-2/errors-and-loss-functions) для его запуска.
{% endhint %}
