# Кейс 2. Классификация с помощью RubixML

В предыдущем кейсе мы разобрали учебную реализацию дерева решений на чистом PHP и увидели механику алгоритма изнутри. Теперь рассмотрим ту же задачу, но уже с использованием готовой библиотеки. Цель этого кейса – показать, как знакомая логика энтропии и [information gain](../../../vvedenie/glossarii.md#information-gain-prirost-informacii) применяется в реальном инструменте и как decision tree интегрируется в обычный PHP-проект.

Этот кейс можно воспринимать как переход от учебной модели к продакшен-подходу.

#### Цель кейса

Цель – обучить модель классифицировать пользователей на "active" и "passive" с помощью готовой реализации дерева решений и понять:

* как организуются данные в библиотеке
* какие параметры управляют поведением дерева
* как происходит обучение и предсказание
* как интерпретировать полученный результат

Важно, что логика задачи остаётся прежней. Меняется только уровень абстракции.

#### Сценарий

Предположим, что у нас есть тот же небольшой набор данных о пользователях сайта:

* количество визитов в неделю
* среднее время на сайте в минутах

Мы хотим быстро обучить модель и использовать её для предсказания поведения нового пользователя.

В реальном проекте такие данные могли бы приходить из базы данных или аналитической системы. Здесь мы задаём их напрямую в коде.

#### Подготовка данных

В RubixML данные разделяются на признаки (samples) и метки (labels). Для классификации используется объект Labeled.

```php
use Rubix\ML\Datasets\Labeled;

$samples = [
    [5, 10],
    [7, 15],
    [1, 2],
    [2, 3],
    [6, 8],
    [3, 4],
    [4, 12],
    [6, 3],
];

$labels = [
    'active', 'active', 'passive', 'passive', 'active', 'passive', 'active', 'passive'
];

$dataset = new Labeled($samples, $labels);
```

На этом этапе мы явно отделяем признаки от целевой переменной. Такой формат данных подчёркивает важный принцип машинного обучения: модель не знает ничего о смысле данных – она работает только с числовыми векторами и метками.

#### Обучение дерева решений

Теперь создадим классификатор и обучим его.

```php
use Rubix\ML\Classifiers\ClassificationTree;

$estimator = new ClassificationTree(
    maxHeight: 5,
    maxLeafSize: 2
);

$estimator->train($dataset);
```

Здесь особенно важно обратить внимание на параметры:

* maxDepth ограничивает глубину дерева
* minSamples определяет минимальное количество объектов в узле для дальнейшего разбиения

Эти параметры напрямую влияют на переобучение. Если убрать ограничения, дерево может идеально запомнить маленький датасет. Ограничивая глубину, мы контролируем сложность модели.

Внутри библиотеки происходит то же самое, что мы реализовывали вручную:

* используется критерий разделения (например, [энтропия](../../../vvedenie/glossarii.md#logika-entropii) или Gini [impurity](../../../vvedenie/glossarii.md#gini-impurity-indeks-dzhini))
* перебираются возможные разбиения
* выбирается вариант с максимальным приростом информативности
* процесс повторяется рекурсивно.

Разница в том, что здесь всё это оптимизировано, протестировано и готово к работе с большими наборами данных.

#### Предсказание

После обучения модель можно использовать для новых пользователей.

```php
$dataset = new Unlabeled([
    [4, 6],
]);

$prediction = $estimator->predict($dataset);

echo $prediction[0];

// Результат
// active
```

Мы передаём массив признаков нового пользователя – 4 визита в неделю и 6 минут среднего времени на сайте. Модель возвращает предсказанный класс - `passive`.

С точки зрения логики, дерево на каждом узле проверяет выбранный признак и соответствующий порог, переходя по ветви до тех пор, пока не дойдёт до листа. Именно этот лист и определяет итоговую метку.

<details>

<summary>Кейс 1. Полный пример кода на RubixML</summary>

```php
use Rubix\ML\Datasets\Unlabeled;
use Rubix\ML\Classifiers\ClassificationTree;
use Rubix\ML\Datasets\Labeled;

// Наш небольшой обучающий набор данных 
// [visits, time]
$samples = [
    [5, 10],
    [7, 15],
    [1, 2],
    [2, 3],
    [6, 8],
    [3, 4],
    [4, 12],
    [6, 3],
];

// Метки классов для каждой строки в $samples
$labels = [
    'active', 'active', 'passive', 'passive', 'active', 'passive', 'active', 'passive'
];

$dataset = new Labeled($samples, $labels);

// Создаёс классификатор на основе дерева решений
$estimator = new ClassificationTree(
    maxHeight: 5,
    maxLeafSize: 2
);

// Создать неразмеченный набор данных для вывода результатов
$estimator->train($dataset);
$dataset = new Unlabeled([
    [4, 6],
]);

$prediction = $estimator->predict($dataset);

// Вывести прогнозируемую метку для первого (и единственного) образца.
echo $prediction[0];
```

</details>

#### Интерпретация результата

Хотя RubixML не всегда визуализирует дерево напрямую, его структура остаётся интерпретируемой. При необходимости можно проанализировать структуру дерева и восстановить ход решения:

* какой признак был выбран для первого разбиения
* какой порог оказался наиболее информативным
* как глубина дерева повлияла на детализацию правил

Если данные маленькие, можно даже вручную воспроизвести возможные пороги и убедиться, что библиотека действует так же, как наш учебный алгоритм.

Это важный момент: использование библиотеки не отменяет понимания алгоритма. Напротив, знание внутренней механики позволяет осознанно выбирать параметры и интерпретировать поведение модели.

#### Практические выводы

Из этого кейса можно сделать несколько выводов.

Во-первых, переход от pure PHP к библиотеке сохраняет принципы алгоритма, но повышает удобство и масштабируемость.

Во-вторых, параметры модели – это не формальность. Они управляют глубиной дерева, степенью обобщения и устойчивостью к переобучению.

В-третьих, decision tree остаётся объяснимой моделью даже в рамках готовой библиотеки. Это делает его удобным инструментом для задач, где важно не только предсказать, но и объяснить результат.

#### Итог

Этот кейс показывает, как теория энтропии и information gain превращается в практический инструмент в PHP-проекте. RubixML берёт на себя вычислительную сложность, но логика алгоритма остаётся прозрачной. Понимая эту логику, разработчик может уверенно использовать деревья решений в реальных системах, не превращая модель в чёрный ящик.

{% hint style="info" %}
Чтобы самостоятельно протестировать этот код, установите примеры из официального репозитория [GitHub](https://github.com/apphp/ai-for-php-developers-examples) или воспользуйтесь [онлайн-демонстрацией](https://aiwithphp.org/books/ai-for-php-developers/examples/part-4/decision-trees-and-space-partitioning) для его запуска.
{% endhint %}
